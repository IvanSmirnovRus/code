Если a, b, c, d - пользовательские типы, то поведение может быть другим, мы предполагаем, что это встроенные типы


a = b + c * d << 2 & 8;                 a = ((b + (c * d)) << 2) & 8;
a & 077 |= 3                            (a & 077) |= 3 - не верное, потому что слева rvalue
a == b || a== c && c < 5;               (a == b) || ((a== c) && (c < 5))
c = x != 0 - c = (x != 0);
0 <= I < 7;                              (0 <= I) < 7; - работает не так, как ожидается
1, 2 + 3;								 1, (2 + 3) - вернет 5
a = -1 ++ b --5                          a = (-1) (++ b) (--5)	- не верно, хотя бы потому что нельзя делать --5, так 5 нигде не хранится в памяти
a = b == c++							 a = (b == (c++))
a = b = c = 0 							 a = (b = (c = 0)); все переменные приравняются 0
a[4][2] *=* b ? c : *d*2				 (a[4][2]) *= ((* b) ? c : ((*d) * 2)) - корректное выражение, при условии, что a - двумерный массив, b и d указатели
a - b , c  = d                           (a - b) , (c  = d) вернется с после приравнивания d
*p++                                     *(p++) верно, если p имеет семантику указателя
*--p									 *(--p) верно, если p имеет семантику указателя
++++a--									 ++(++(a--)) - не верно, потому что a-- rvalue
(-(++(++a)))--							 (-(++(++a)))-- не верно, потому что унарный минус возвращает rvalue
++a--                                    ++(a--) - не верно, потому что дикримент возвращает lvalue
(int *)p->m                              (int *)(p->m) верно, p должен быть указателем на структуру или класс, где есть поле m, которое является указателем
*p.m                                     *(p.m) - верно, p - структура или класс с полем m
*a[i]                                    *(a[i]) - верно, разыименовывется i-ый элемент
a, b = b, a								 a, (b = b), a - вернется a
